
# 二刷大总结
直接上一维数组，可以减少初始化的麻烦

一维数组下dp[0] 需不需要额外照顾，具体情况具体分析。其中最大值问题，初始化为0刚好也满足dp[0]的含义，所以不用特殊照顾。但是其他问题(最小值，存在，组合问题)中，因为数组初始化的值不能反映dp[0]的意义，都是需要特殊照顾的。


[递归到动态规划](https://leetcode.cn/problems/combination-sum-iv/solutions/740877/fu-xue-ming-zhu-cong-ji-yi-hua-di-gui-tu-rqwy/)

[一篇文章吃透背包问题！（细致引入+解题模板+例题分析+代码呈现）](https://leetcode.cn/problems/last-stone-weight-ii/solution/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-5lfv/)

**究极口诀，==放或者不放，放就要准备空间==**

**每个dp[i][j]可以分为两个互补集，不含weight[i]和含weight[i]**
 + **不放==照抄==上一行就行**
 + **放weight[i]的情况， 要先==准备出==能放得下weight[i]背包, 即dp[j - weight[i]]**，这也解释了一维数组方法中为什么第二层for循环要从weight[i]开始，因为根本就不可能放进去啊

**0 / 1背包考虑的是第i个物品放不放**
**完全背包考虑的是第i个物品要不要再放一次**
**这个区别也导致也以下的不同：**

**0 / 1背包是==上==和==左上==两个元素的关系式**
**完全背包是==上==和==左==两个元素的关系式**

背包容量可以是0，他是有意义的，而且不表示空，因为你清空了背包就是为了放进去当前物品

以上是背包问题的本质，至于三种问题形式，只是表象，三种形式用的是同样的递推逻辑，只不过dp[i][j]意义不同
+ 最值问题: 
  dp[j] = max/min(dp[j], dp[j - weight[i]] + 1) 或
  dp[j] = max/min(dp[j], dp[j - weight[i]] + val[i]);
+ 存在问题(bool)：
  dp[j]=dp[j] or dp[j - weight[i]];
+ 组合问题：
  dp[j] += dp[j - weight[i]]





背包问题大纲

动态规划：01背包理论基础
动态规划：01背包理论基础（滚动数组）
动态规划：416.分割等和子集 (0/1存在)
动态规划：1049.最后一块石头的重量II (0/1最值)
动态规划：494.目标和 (0/1组合)
动态规划：474.一和零 (0/1组合三维)
动态规划：完全背包总结篇
动态规划：518.零钱兑换II (完全组合)
动态规划：377.组合总和Ⅳ (完全组合)
动态规划：70.爬楼梯（完全）
动态规划：322.零钱兑换 (完全最值)
动态规划：279.完全平方数 (完全最值)
动态规划：139.单词拆分

+ 最值问题
  + 1049.最后一块石头的重量II(0/1)
    <pre>
    dp = [0] * (target + 1)
    for i in range(len(stones)):
        for j in range(target, stones[i]-1, -1):
            dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])
    </pre>
  + 474.一和零(0/1, **三维**)
    <pre>
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for k in range(len(strs)):
        ones = strs[k].count('1')
        zeros = strs[k].count('0')
        for i in range(m, zeros - 1, -1):
            for j in range(n, ones - 1, -1):
                dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)
    </pre>
  + 322.零钱兑换(完全, **最小**)
    <pre>
    dp = [float('inf')] * (amount + 1)
    <b>dp[0] = 0</b>
    for i in range(len(coins)):
        for j in range(coins[i], amount + 1):
            dp[j] = min(dp[j], dp[j - coins[i]] + 1)
    return dp[-1] if dp[-1] != float('inf') else -1
    </pre>
  + 279.完全平方数(完全, 最小)
  **跟322零钱兑换类似**
    <pre>
    dp = [float('inf')] * (n + 1)
    dp[0] = 0
    for i in range(1, math.ceil(math.sqrt(n)) + 1):
        for j in range(i**2, n + 1):
            dp[j] = min(dp[j], dp[j - i**2] + 1)
    </pre>
+ 存在问题 - 问存在不存在
  + 416.分割等和子集(0/1)
    <pre>
    dp = [False] * (target + 1)
    <b>dp[0] = True</b>
    for i in range(len(nums)):
        for j in range(target, -1, -1):
            if nums[i] <= j:
                dp[j] = dp[j] or dp[j - nums[i]]
    </pre>
  + 139.单词拆分 (完全，排列)
    <pre>
    dp = [False] * (len(s) + 1)
    dp[0] = True
    for j in range(len(s) + 1):
        for word in wordDict:
            dp[j] = dp[j] or (dp[j - len(word)] and word == s[j - len(word): j])
    </pre>
+ 组合问题(**没有val数组**) - 问存在几个
  + 494.目标和(0/1，组合)
    <pre>
    dp = [0] * (bagSize + 1)
    <b>dp[0] = 1</b>
    for i in range(len(nums)):
        for j in range(bagSize, nums[i] -1, -1):
            dp[j] += dp[j - nums[i]]
    </pre>
  + 518.零钱兑换II(完全, 组合)
    <pre>
    dp = [0] * (amount + 1)
    <b>dp[0] = 1</b>
    for i in range(len(coins)):
        for j in range(coins[i], amount + 1):
            dp[j] += dp[j - coins[i]]
    </pre>
  + 377.组合总和 Ⅳ(完全， 排列)
    <pre>
    dp = [0] * (target + 1)
    dp[0] = 1
    for i in range(len(nums)):
        for j in range(nums[i], target + 1):
            dp[j] += dp[j - nums[i]]
    </pre>
  + 70.爬楼梯(完全，排列)
    <pre>
    dp = [0] * (n + 1)
    dp[0] = 1
    for j in range(n + 1):
        for i in [1, 2]:
            if j >= i:
                dp[j] = dp[j] + dp[j - i]
    </pre>


494.目标和 vs 416.分割等和子集
目标和求组合个数，分割等和子集求存不存在，本质上组合个数大于0就表示存在，也可以用经典背包对dp[-1]==target进行判断，不过就更绕了

1.    最后一块石头的重量 II（首先，先将问题转换为背包问题）
dp[i][j]含义:从前i块石头中选取，选取值之和小于等于目标值j的最大值为dp。（i、j分别对应从外到内两层循环。）

1.   零钱兑换
dp[i][j]含义:前i种面额的硬币，组成总额为j金额使用的最少硬币数为dp。（i、j分别对应从外到内两层循环。）

1.   分割等和子集（首先，先将问题转换为背包问题）
dp[i][j]含义:对nums的前i个元素进行选取，dp记录是否存在选取值相加结果为目标值j。（dp是bool型）（i、j分别对应从外到内两层循环。）

1.   目标和（首先，先将问题转换为背包问题）
dp[i][j]含义:对nums的前i个元素进行选取相加值为目标值j的组合个数为dp。（i、j分别对应从外到内两层循环。）

1.   完全平方数（首先，先将问题转换为背包问题）
dp[i][j]含义:前i个完全平方数，组成目标值j时，使用的完全平方数最少个数为dp。（i、j分别对应从外到内两层循环。）

1.   组合总和 Ⅳ
dp[i][j]含义:组成目标值为i的组合的最后一个数是nums[j]的组合的个数为dp。（i、j分别对应从外到内两层循环。）。注：因为本题需要考虑组合的顺序，顺序不同则被视为不同的组合。所以状态定义要考虑到每种目标值的最后一个nums的选取上。

1.   零钱兑换 II
dp[i][j]含义:前i种面额的硬币，组成总额为j的金额的不同组合个数为dp（i、j分别对应从外到内两层循环。）。

1.    掷骰子的N种方法：
dp[i][j]含义:前i个骰子总点数为j的不同组合个数为dp（i、j分别对应从外到内两层循环。）。最内侧对骰子面数的循环，是一个累加过程（最后一个骰子每个面朝上组合数的累加）。

# 0/1背包
## 二维背包
1. **DP问题第一步，画表格，画表格，画表格**
   + 帮助理解题意
   + 帮助写递推公式
   + 帮助debug   
2. **易错点非常多**
3. **易错1** Python list的行和列，**先列数后行数**
    ```python
    dp = [[-1 for _ in range(c+1)] for _ in range(len(w))]
    ```
4. **易错2** 物品的遍历是range(**1**, len(weight)),因为已经初始化了
5. **易错3** 背包容量遍历是c+**1**
6. **口诀1**：**放**物品i**还是不放**物品i，是个问题。对于unboundied 背包，要么不放物品i，要么尽可能多的放物品i，这个尽可能多，是在table中的同行的左边实现的。
7. **口诀2**：**向左上取值**
8. 经典五部曲
   + 设未知数
   + 写递推式
   + 定初始化
   + 遍历顺序
   + 列表debug
9. **我看只有两步**：
   + 设未知数 **最关键，一定要明确的写出来，才能防止算列表时出错**
   + 列表 

10. dp[i][j]的含义，**前i个物品(inclusive)**装到容量为j的包里所能得到的最大收益
11. 递推公式的理解
   ```python
   dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])
   ```
   + 相对于传统递推公式，这里用的是**max()**
   + 第一项是递推传统格式，代表**不放**进新物品，以防塞了个赔钱货
   + 第二项是**无论**背包有没有足够的剩余空间，**都放**进新物品的结果。这里[j-weight[i]]是无论如何**都要减weight[i]的**，即使有足够空间。
12. 初始化从0或者1开始无所谓，都可以递推出后面的值。目前是都从0开始，但行和列的0有不同的含义。行的0是指下标为0的物品，也就是第一个物品。**列的0是指背包容量为0时，也就是没有背包，这个情况实际上是无意义的**，但是它的存在正好使j的值就是背包容量的值，而不用进行转化。
13. 最优子结构VS重叠子问题
大问题可以划分为子问题，但子问题不一定重叠，也就是有最优子结构不一定有重叠子问题

## 一维背包
1. 最大的特点是**倒序**遍历。原因是递推的本质是往左上取值，如果正序遍历就会contaminate左上元素。

# 完全背包 Unboundied knapsack
1. 完全背包与0/1背包最大的区别是物品能否**重复**抽取，所以算法上：
   + 0/1 **左上 + 上**
   + 完全 **左  + 上**

# Boundied knapsack
1. 特点：物品既不是只能抽一次，也不是无限次，而是**有限次**
买卖股票问题最关键的就是设未知数，太奇葩了