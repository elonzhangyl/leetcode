# 大总结
+ 抓住设什么: **以nums[i]为结尾**的最长递增子序列长度
# 题目

动态规划：392.判断子序列
<pre>
dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]
for i in range(1, len(s) + 1):
    for j in range(1, len(t) + 1):
        if s[i - 1] == t[j - 1]:
            dp[i][j] = dp[i - 1][j - 1] + 1
        else:
            dp[i][j] = dp[i][j - 1]
return True if dp[-1][-1] == len(s) else False
</pre>
动态规划：115.不同的子序列
<pre>
dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]
for i in range(len(s) + 1):
    dp[i][0] = 1  <b>注意初始化</b>
for i in range(1, len(s) + 1):
    for j in range(1, len(t) + 1):
        if s[i - 1] == t[j - 1]:
            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
        else:
            dp[i][j] = dp[i - 1][j]
return dp[-1][-1]
</pre>
动态规划：583.两个字符串的删除操作
<pre>
res = 0
dp = [[0] * (len(word2) + 1) for _ in range(len(word1) + 1)]
for i in range(1, len(word1) + 1):
    for j in range(1, len(word2) + 1):
        if word1[i - 1] == word2[j - 1]:
            dp[i][j] = dp[i - 1][j - 1] + 1
        else:
            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        res = max(res, dp[i][j])
return len(word1) + len(word2) - 2 * res
</pre>
动态规划：72.编辑距离
<pre>
dp = [[0] * (len(word2) + 1) for _ in range(len(word1) + 1)]
for i in range(1, len(word1) + 1):
    dp[i][0] = i
for j in range(1, len(word2) + 1):
    dp[0][j] = j
for i in range(1, len(word1) + 1):
    for j in range(1, len(word2) + 1):
        if word1[i - 1] == word2[j - 1]:
            dp[i][j] = dp[i - 1][j - 1]
        else:
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
return dp[-1][-1]
</pre>
编辑距离总结篇
动态规划：647.回文子串
动态规划：516.最长回文子序列
动态规划总结篇