# 大总结
+ 抓住设什么: **以nums[i]为结尾**的最长递增子序列长度
# 题目
+ 300.最长递增子序列 (单个看递增，不要求连续)
  dp的含义是以nums[i]为结尾的最长递增子序列长度，而不仅仅是像背包问题里考虑到nums[i]
  <pre>
  <b>到处是坑</b>
    dp = [1] * len(nums) <b>初始化为1，想想dp定义，因为以nums[i]结尾的至少长度为1，而不是0</b>
    for i in range(1, len(nums)):<b>套路</b>
        for j in range(i):<b>套路</b>
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1) <b>迭代出最大的</b>
    return max(dp) <b>这里return的是其中的最大值，而不是最后一个值</b>
  </pre>

动态规划：674.最长连续递增序列 (单个看递增，要求连续)
<pre>
for i in range(1, len(nums)):
    if nums[i] > nums[i - 1]:
        dp[i] = dp[i - 1] + 1
return max(dp)
</pre>
动态规划：718.最长重复子数组 (两个看重复，要求连续)
<pre>
dp = [[0] * len(nums2) for _ in range(len(nums1))]
for i in range(len(nums1)):
    for j in range(len(nums2)):
        if nums1[i] == nums2[j]:
            if i == 0 or j == 0:
                dp[i][j] = 1
            else:
                dp[i][j] = dp[i - 1][j - 1] + 1
return np.max(np.array(dp))
</pre>
动态规划：1143.最长公共子序列 (两个看重复，不要求连续)
**我还是需要从dp[0][0]开始，他们没有物理的意义，但是在递推过程中不可或缺**
**但是这里与背包不同，这里的j默认是list的索引，而不是背包容量，所以要特殊处理一下**
<pre>
dp = [[0] * (len(text2) + 1)for _ in range(len(text1)+1)]
for i in range(1, len(text1)+1):
    for j in range(1, len(text2)+1):
        if text1[i - 1] == text2[j - 1]: <b>特殊处理</b>
            dp[i][j] = dp[i - 1][j - 1] + 1
        else:
            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        res = max(res, dp[i][j])
</pre>
动态规划：1035.不相交的线
动态规划：53.最大子序和
动态规划：392.判断子序列
动态规划：115.不同的子序列
动态规划：583.两个字符串的删除操作
动态规划：72.编辑距离
编辑距离总结篇
动态规划：647.回文子串
动态规划：516.最长回文子序列
动态规划总结篇