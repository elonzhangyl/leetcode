# 大总结
+ 只有两种设法
  + 一维: 以nums[i]为结尾的数组的所求值为dp[i]
  + 二维: nums[i][j]内包含的所求值为dp[i][j]
+ 抓住设什么: **以nums[i]为结尾**的最长递增子序列长度
# 题目
+ 300.最长递增子序列 (单个看递增，不要求连续)
  dp的含义是以nums[i]为结尾的最长递增子序列长度，而不仅仅是像背包问题里考虑到nums[i]
  <pre>
  <b>到处是坑</b>
    dp = [1] * len(nums) <b>初始化为1，想想dp定义，因为以nums[i]结尾的至少长度为1，而不是0</b>
    for i in range(1, len(nums)):<b>套路</b>
        for j in range(i):<b>套路</b>
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1) <b>迭代出最大的</b>
    return max(dp) <b>这里return的是其中的最大值，而不是最后一个值</b>
  </pre>

+ 动态规划：674.最长连续递增序列 (单个看递增，要求连续)
<pre>
for i in range(1, len(nums)):
    if nums[i] > nums[i - 1]:
        dp[i] = dp[i - 1] + 1
return max(dp)
</pre>
+ 动态规划：718.最长重复子数组 (两个看重复，要求连续)
<pre>
dp = [[0] * len(nums2) for _ in range(len(nums1))]
for i in range(len(nums1)):
    for j in range(len(nums2)):
        if nums1[i] == nums2[j]:
            if i == 0 or j == 0:
                dp[i][j] = 1
            else:
                dp[i][j] = dp[i - 1][j - 1] + 1
return np.max(np.array(dp))
</pre>
+ 动态规划：1143.最长公共子序列 (两个看重复，不要求连续)
**dp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]**
**我还是需要从dp[0][0]开始，他们没有物理的意义，但是在递推过程中不可或缺**
**但是这里与背包不同，这里的j默认是list的索引，而不是背包容量，所以要特殊处理一下**
<pre>
dp = [[0] * (len(text2) + 1)for _ in range(len(text1)+1)]
for i in range(1, len(text1)+1):
    for j in range(1, len(text2)+1):
        if text1[i - 1] == text2[j - 1]: <b>特殊处理</b>
            dp[i][j] = dp[i - 1][j - 1] + 1
        else:
            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
return dp[-1][-1]
</pre>
+ 动态规划：53.最大子序和
**dp[i]：包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]**
<pre>
dp = [0] * len(nums)
dp[0] = nums[0] # 初始化
for i in range(1, len(nums)):
    dp[i] = max(dp[i - 1] + nums[i], nums[i])
return max(res)
</pre>
+ 动态规划：647.回文子串 (要求连续)
**设以i为开头j为结尾的字符串是否是回文串**
<pre>
res = 0
dp = [[0] * len(s) for _ in range(len(s))]
for i in range(len(s) - 1, -1, -1):<b>递推逻辑决定了遍历顺序</b>
    for j in range(i, len(s)):
        if s[i] == s[j]:
            if i == j or j - i == 1:
                dp[i][j] = 1
            else:
                dp[i][j] = dp[i + 1][j - 1]
        else:
            dp[i][j] = 0
        res += dp[i][j]
return res
</pre>
动态规划：516.最长回文子序列 (不要求连续) 
<pre>       
dp = [[0] * len(s) for _ in range(len(s))]
for i in range(len(s) - 1, -1, -1):
    for j in range(i, len(s)):
        if s[i] == s[j]:
            if i == j:
                dp[i][j] = 1
            elif j - i == 1:
                dp[i][j] = 2
            else:
                dp[i][j] = dp[i + 1][j - 1] + 2
        else:
            dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
        res = max(res, dp[i][j])
</pre>