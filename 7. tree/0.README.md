recursion https://blog.csdn.net/storyfull/article/details/102671946
recursion都可以用stack解决；都是先解决后进入的问题
切记：对tree用stack的时候，要先右后左，反着来
1. full binary tree vs complete binary tree
    完全二叉树就是**只缺右下角**，（最后一层左边都满，其他层都满）
2. 二叉树VS二叉**搜索**树
   二叉搜索树有数值，且满足二分法关系(可以用来搜索)
3. 二叉树主要有两种遍历方式：
 + 深度优先遍历
   + 前序遍历（递归法，迭代法）
   + 中序遍历（递归法，迭代法）
   + 后序遍历（递归法，迭代法）
这里前中后，其实指的就是==中间节点的遍历顺序==
 + 广度优先遍历
   + 层次遍历（迭代法）
4. 所谓的前中后序遍历，其实是前中后序采集，遍历顺序都是一样的，区别只在于什么时候采集的数据

# 题目
 + 二叉树：226.翻转二叉树
<pre>
if node:
    <mark>node.left, node.right = node.right, node.left</mark>
    self.traverse(node.left)
    self.traverse(node.right)
</pre>
 + 二叉树：101.对称二叉树
   难, ==还真是有点难==
 + 二叉树：222.完全二叉树的节点个数
 + 二叉树：110.平衡二叉树
 + 二叉树：257.二叉树的所有路径
```python
if node:
    self.path.append(node.val)
    self.traverse(node.left)
    self.traverse(node.right)
    if not node.left and not node.right:
        self.res.append(self.path[:])
    self.path.pop()
```
 + 二叉树：404.左叶子之和
```python
if node:
    if node.left and not node.left.left and not node.left.right:
        self.res += node.left.val
    self.traverse(node.left)
    self.traverse(node.right)
```
 + 二叉树：513.找树左下角的值

 + 二叉树：112.路径总和
  ==非常典型，联系其回溯框架，大通==
二叉树：106.构造二叉树
二叉树：654.最大二叉树
二叉树：617.合并两个二叉树
二叉树：700.二叉搜索树登场！
二叉树：98.验证二叉搜索树
二叉树：530.搜索树的最小绝对差
二叉树：501.二叉搜索树中的众数
二叉树：236.公共祖先问题
二叉树：235.搜索树的最近公共祖先
二叉树：701.搜索树中的插入操作
二叉树：450.搜索树中的删除操作
二叉树：669.修剪二叉搜索树
二叉树：108.将有序数组转换为二叉搜索树
二叉树：538.把二叉搜索树转换为累加树
# 构造二叉树
+ 654 题「 最大二叉树」
  简单，找到最大值，两侧的就是左右子树的节点值
+ 105 题「 从前序和中序遍历序列构造二叉树」
要从数组找到三个关键元素，根结点，左侧节点值，右侧节点值
+ 106 题「 从后序和中序遍历序列构造二叉树」
+ 889 题「 根据前序和后序遍历构造二叉树」
# 层序遍历
1. 维护队列，**出一进二**
   <pre>
    <mark>if not root:
        return 0</mark>
    que = [root]
    depth = 0
    <mark>while que:</mark>
        for _ in range(len(que)):
            <mark>node = que.pop(0)</mark>
            if node.left:
                que.append(node.left)
            if node.right:
                que.append(node.right)
    </pre>
2. 只要会层序遍历模版，题目都是**简单修改**(两三行)
3. 题目
 + 102.二叉树的层序遍历
 + 107.二叉树的层次遍历II
 + 199.二叉树的右视图
 + 637.二叉树的层平均值
 + 429.N叉树的层序遍历
 + 515.在每个树行中找最大值
 + 116.填充每个节点的下一个右侧节点指针
 + 117.填充每个节点的下一个右侧节点指针II
 + 104.二叉树的最大深度
 + 111.二叉树的最小深度

# 二叉搜索树
node.val具有一些性质的二叉树

