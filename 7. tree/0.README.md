recursion https://blog.csdn.net/storyfull/article/details/102671946
recursion都可以用stack解决；都是先解决后进入的问题
切记：对tree用stack的时候，要先右后左，反着来
1. full binary tree vs complete binary tree
    完全二叉树就是**只缺右下角**，（最后一层左边都满，其他层都满）
2. 二叉树VS二叉**搜索**树
   二叉搜索树有数值，且满足二分法关系(可以用来搜索)
3. 二叉树主要有两种遍历方式：
 + 深度优先遍历
   + 前序遍历（递归法，迭代法）
   + 中序遍历（递归法，迭代法）
   + 后序遍历（递归法，迭代法）
这里前中后，其实指的就是==中间节点的遍历顺序==
 + 广度优先遍历
   + 层次遍历（迭代法）
4. 所谓的前中后序遍历，其实是前中后序采集，遍历顺序都是一样的，区别只在于什么时候采集的数据

# 题目
 + 二叉树：226.翻转二叉树
<pre>
if node:
    <mark>node.left, node.right = node.right, node.left</mark>
    self.traverse(node.left)
    self.traverse(node.right)
</pre>
<pre>
<b>这里对children做遍历就不行了</b>
def backtrack(self, root):
    if not root:
        return
    root.left, root.right = root.right, root.left
    for child in [root.left, root.right]:
        self.backtrack(child)
</pre>
 + ==二叉树：101.对称二叉树==**嗷嗷经典**
<pre>
def backtrack(self, left, right):
    if left == None and right != None:
        return False
    elif left != None and right == None:
        return False
    elif left == None and right == None: 
        return True
    elif left.val != right.val: 
        return False

    for i in [[left.left, right.right],[left.right, right.left]]: 
    <mark>这里遍历的到底是谁, 不是全层, 而是此层的一个基本单元内的所有可能值</mark>
        if self.backtrack(*i) == False:
            return False
            <mark>遇到一个就返回</mark>
    return True
    <mark>每层循坏都要对应一个return</mark>
 </pre>
+ 二叉树：222.完全二叉树的节点个数
  + 遍历思想
<pre>
def backtrack(self, children):
    if not children[0] and not children[1]:
    <mark>这里的终止条件的判断，如果遍历的是children，如果遍历的是root</mark>
        return
    for child in children:
        if child:
            self.c += 1
            self.backtrack([child.left, child.right])
</pre>
  + 分解问题思想
<pre>
<b>这里的子问题是一个node尖所代表的三角形中，有多少nodes</b>
def getNodesNum(self, cur):
    if not cur:
        return 0
    <b>递归终止条件还是一如既往</b>
    c2 = 0
    for child in [cur.left, cur.right]:
        c1 = self.getNodesNum(child)
        c2 += c1
    return c2 + 1 
    <b>这里加1加的是那个尖尖</b>
</pre>
 + 二叉树：110.平衡二叉树
<pre>
def get_height(self, node: TreeNode) -> int:
    if not node:
        return 0
    h_left = self.backtrack(node.left)
    h_right = self.backtrack(node.right)
    if abs(h_left - h_right) > 1:
        return -1
    <b>这里对返回值进行了判断</b>
    if h_left == -1:
        return -1
    if h_right == -1:
        return -1
    return max(h_left, h_right) + 1
    <b>如何计算高度</b>
    <b>如果递归函数需要有返回值，应该怎么办</b>
    <mark>大亮点：这个返回值整合了两个含义。一是高度，二是是否平衡(-1)</mark>
</pre>
 + 二叉树：257.二叉树的所有路径(后序)
   + 二叉树写法
```python
if node:
    self.path.append(node.val)
    self.traverse(node.left)
    self.traverse(node.right)
    if not node.left and not node.right:
        self.res.append(self.path[:])
    self.path.pop()
```
   + n叉树写法：对children进行遍历
<pre>
def binaryTreePaths(self, root):
    self.traverse(<b>[root]</b>)
    <mark>此处切记变数组</mark>
    return res_sorted
def backtrack(self, children):
    if not children[0] and not children[-1]:
        self.res.append(self.path[:])
    for child in children:
        if child:
        <b>必须对child的存在进行判断，因为要用到.val，相当于剪枝</b>
            self.path.append(child.val)
            self.backtrack([child.left, child.right])
            self.path.pop()
</pre>
   + n叉树写法：对node进行遍历 (这种写法无法遍历root，因为上来就进入left/right了)
<pre>
def traverse(self, node):
    if not node.left and not node.right:
    <b>终止条件语句稍有不同</b>
        self.res.append(self.path[:])
    for child in [node.left, node.right]:
        if child:
            self.path.append(child.val)
            self.traverse(child)
            self.path.pop()
</pre>
 + 二叉树：404.左叶子之和
```python
if node:
    if node.left and not node.left.left and not node.left.right:
        self.res += node.left.val
    self.traverse(node.left)
    self.traverse(node.right)
```
<pre>
def traverse(self, children):
    if not children[0] and not children[1]:
        return
    for child in children:
        if child:
        <mark>防止单边情况</mark>
            self.traverse([child.left, child.right])
            <mark>if child.left and not child.left.left and not child.left.right:
                self.res += child.left.val</mark>
            <b>这是个经典</b>
</pre>
 + 二叉树：513.找树左下角的值
  **显然无脑层序**
 + 二叉树：112.路径总和
  ==非常典型，联系其回溯框架，大通==
<pre>
def hasPathSum(self, root, targetsum: int) -> bool:
    if not root:
        return False
    <mark>上来就是判断root为空</mark>
    if self.backtrack([root], targetsum):
        return True

def backtrack(self, children, target):
    if not children[0] and not children[-1]:
        if self.res == target:
            return True
        return False
        <mark>这里要返回False不能返回空</mark>
    
    for child in children:
        if child:
        <mark>此处还是要先判断</mark>
            self.res += child.val
            if self.backtrack([child.left, child.right], target):
                return True
            <mark>遇到就返回对应用</mark>
            self.res -= child.val
</pre>
**另外一种方法，对root进行遍历**
<pre>
def hasPathSum(self, root, targetSum):
    if not root:
        return False
    return self.backtrack(root, targetSum - root.val)

def backtrack(self, root, targetSum):
    if not root.left and not root.right: 
        if targetSum == 0:
            return True
        else:
            return False

    for child in [root.left, root.right]:
        if child:
            targetSum -= child.val
            if self.backtrack(child, targetSum):
                return True
            targetSum += child.val
</pre>
二叉树：700.二叉搜索树登场！
二叉树：98.验证二叉搜索树
二叉树：530.搜索树的最小绝对差
二叉树：501.二叉搜索树中的众数
二叉树：236.公共祖先问题
二叉树：235.搜索树的最近公共祖先
二叉树：701.搜索树中的插入操作
二叉树：450.搜索树中的删除操作
二叉树：669.修剪二叉搜索树
二叉树：108.将有序数组转换为二叉搜索树
二叉树：538.把二叉搜索树转换为累加树
# 构造二叉树
+ 654 题「 最大二叉树」
  简单，找到最大值，两侧的就是左右子树的节点值
+ 105 题「 从前序和中序遍历序列构造二叉树」
要从数组找到三个关键元素，根结点，左侧节点值，右侧节点值
其实每次分割之后左右两段刚好重复上一次的分割逻辑，具体见下图
![](2.jpeg)
+ 106 题「 从后序和中序遍历序列构造二叉树」
+ 889 题「 根据前序和后序遍历构造二叉树」
+ 二叉树：617.合并两个二叉树
# 层序遍历
1. 维护队列，**出一进二**
   <pre>
    <mark>if not root:
        return 0</mark>
    que = [root]
    depth = 0
    <mark>while que:</mark>
        for _ in range(len(que)):
            <mark>node = que.pop(0)</mark>
            if node.left:
                que.append(node.left)
            if node.right:
                que.append(node.right)
    </pre>
2. 只要会层序遍历模版，题目都是**简单修改**(两三行)
3. 题目
 + 102.二叉树的层序遍历
 + 107.二叉树的层次遍历II
 + 199.二叉树的右视图
 + 637.二叉树的层平均值
 + 429.N叉树的层序遍历
 + 515.在每个树行中找最大值
 + 116.填充每个节点的下一个右侧节点指针
 + 117.填充每个节点的下一个右侧节点指针II
 + 104.二叉树的最大深度
 + 111.二叉树的最小深度

# 二叉搜索树
node.val具有一些性质的二叉树

