# 应试技巧
1. 做题分两步，第一画图除思路，第二落实代码
2. 没有做不出来的题，你只是还没分析清楚思路，图没画出来
3. 拿到一道题，先看是遍历还是分解子问题(有递推公式)，这决定了大思路
4. 克服时间不够，做不出来的无效焦虑 - 享受解题过程，无论结果
5. 为什么总是忘记return呢
6. not [] = True; not [None] = Flase
7. 没有做不出来的题，你只是
# 金刚经
1. 数据结构就是
   + 数组
   + 链表
2. 算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”，又分
   + 遍历思想(剪枝)
   + 分解问题思想(如果存在子结构的话；比遍历优化)
  两者都用到递归，一个是遍历所有可能options，一个是遍历所有子问题
# 天龙八部
+ 迭代解决不了的：
+ 递归解决不了的：
+ 回溯解决不了的：
  - 目标和问题，分配正负号是O(2<sup>n</sup>)，只会超时
+ 动规解决不了的：

# 易筋经
+ 二叉树/回溯**终极**框架
<pre>
def traverse/backtrack(self, ):
    这个递归函数里只需要考虑两种情况：
    + 要么是正常递归，可以没有返回值，那就是遍历整棵树
    + 要么是触底反弹，必要有返回值，不然stack overflow
  
    <mark>什么时候触底反弹，就是判断是否到底了.</mark> <b>控制纵向</b>
    <b><mark>if</mark></b> ...: (注释1)
        (操作4：触底时)
        return ...
    <mark>怎么处理正常情况(也就是递归)</mark>
    <b><mark>else</mark></b>:(注释4)
        for i in ...: (注释2)
            (操作1: 前序)
            self.traverse(i)
            (操作2: 中序 - 二叉树写法)
            (操作3: 后序)
         return ... (注释3)
        
</pre>
+ 操作1，2，3:
这里是前中后序位置，骚操作很多，也是进行剪枝的地方
如果有回溯，就要在这里展现对称美了
+ 操作1: 前序
  - 经典的回溯问题其实都是前序，因为搜集**路径**必须从根开始
  - 剪枝
    * 40.组合总和II
从n个数(n个数有可能相同，不可重复选取)中返回任意个数的组合，和为target，结果不可重复 
    ```if i > 0 and nums[i] == nums[i-1]:```
+ 操作2: 中序
+ 操作3: 后序
  应用最大，除了上面提及的几个需要前序或中序，其他的都可以用后序
+ 操作4: 这里触底了要做一些事情，可能是return None，也可能是搜集结果(路径)。触底反弹的情况很能有多个，为了简洁我就不写表示了
  - 比如目标和问题，考虑的是所有元素都用完，所以要触底才做判断
  <pre>
   if idx == len(nums):
      if self.sum == target:
            self.res += 1
   return
   </pre>
+ 注释1:
  - 如果深度已知(比如**不可**重复抽取的排列组合问题)
   ```if idx == len(nums):```
  - 如果深度未知(比如**可**重复抽取的排列组合问题)
   ```if self.sum == target```
+ 注释1:
self.traverse() <b>一个就是单根递归</b>
self.traverse() <b>多个就是多根递归，扩展横向</b>
(这里的形式<b>还</b>可以是:
h_left = self.traverse()
h_right = self.traverse() ... 采集问题
--
if self.traverse() == True ...遇到就返回问题
--
node.left = self.traverse() 
node.right = self.traverse() ...构造问题
)
+ 注释3
return有两种方式，一种是显性的直接写出return什么，另一种是隐形的，通过全局变量 self.path 来搞.
+ 注释4
  这个else有点地方不能要。比如无限抽取的组合问题，触底条件是满足某个sum==target，这个是柔性的，如果超过了，得给人家机会再减回去
  ```python
  if self.sum == amount:
     return
   for i in range(len(coins)):
      self.sum += coins[i]
      self.path.append(coins[i])
      self.sum -= coins[i]
   ```

# 大总结
1. [所有的数据结构都是list或者链表](https://labuladong.github.io/algo/di-ling-zh-bfe1b/xue-xi-sua-01220/)
  + 数据可以链式存储，也可以顺序存储。那么链式存储方式就用指针， 顺序存储的方式就是用数组。
  + 顺序存储就用==for==，链式存储就用==while==，乎哈哈哈哈
2. [对于任何数据结构，其基本操作无非遍历 + 访问，再具体一点就是：增删查改。](https://labuladong.github.io/algo/di-ling-zh-bfe1b/xue-xi-sua-01220/)
3. [所有的算法都是穷举](https://labuladong.github.io/algo/di-ling-zh-bfe1b/wo-de-shua-5fe0c/)
4. [DFS 、动态规划、回溯法、递归之间的关系是什么？](https://www.zhihu.com/question/266403334/answer/698464437)
5. 二叉树vs回溯
   二叉树遍历是记录下所有节点即可；回溯是要记录下所有(可行)路径，所以需要append和pop
6. 二叉树这种结构无非就是二叉链表，排列问题回溯发无非就是n叉链表



## 递归
1. 递归是一种函数调用思想，典型应用如阶乘
2. 只要有递归，就有前序位置和后续位置，代码写在不同位置，代码执行的时机也不同
### 迭代和递归
1. 迭代只能从前往后，递归有前序位置后序位置，比迭代更为灵活(例题：倒序打印单链表)
## 回溯
[回溯是带for循环的递归](https://leetcode.cn/problems/permutations/solutions/9914/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/)
### 回溯VS动规
+ 回溯自上而下(fib(20)->fib(19)+fib(18))，所以要用==递归==
+ 动规自下而上(fib(1),fib(2)...->fib(20))，所以可以用for循环。aka ==递推==
### 树VS回溯
+ 树是所有节点的值已经被赋好了，回溯需要你自己决定怎么赋值
# 动态规划
+ 动态规划之所以比暴力算法快，是因为动态规划技巧消除了重叠子问



